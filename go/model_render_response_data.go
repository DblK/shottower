/*
shottower
Copyright (C) 2022 RÃ©my Boulanouar

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
/*
 * Shottower
 *
 * Shottower is the open source version of Shotstack which is a video, image and audio editing service that allows for the automated generation of videos, images and audio using JSON and a RESTful API.  You arrange and configure an edit and POST it to the API which will render your media and provide a file  location when complete.  For more details visit [shottower](https://github.com/DblK/shottower) or checkout our [getting started](https://shotstack.io/docs/guide/) documentation.  There are two main API's, one for editing and generating assets (Edit API) and one for managing hosted assets (Serve API).  The Edit API base URL is: <b>http://0.0.0.0:4000/{version}</b>  The Serve API base URL is: <b>http://0.0.0.0:4000/serve/{version}</b>
 *
 * API version: stage
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

type RenderResponseStatus int64

const (
	Queued RenderResponseStatus = iota
	Fetching
	Rendering
	Saving
	Done
	Failed

	// Internal
	Fetched
	Rendered
	Generating
	Generated
)

func (s RenderResponseStatus) String() string {
	switch s {
	case Queued:
		return "queue"
	case Fetching:
		return "fetching"
	case Rendering:
		return "rendering"
	case Saving:
		return "saving"
	case Done:
		return "done"
	case Failed:
		return "failed"

		// Internal
	case Fetched:
		return "fetched"
	case Rendered:
		return "rendered"
	case Generating:
		return "generating"
	case Generated:
		return "generated"
	}
	return "unknown"
}

// RenderResponseData - The response data returned with the [RenderResponse](#tocs_renderresponse) including status and URL.
type RenderResponseData struct {

	// The id of the render task in UUID format.
	ID string `json:"id"`

	// The owner id of the render task.
	Owner string `json:"owner"`

	// The customer subscription plan.
	Plan string `json:"plan,omitempty"`

	// The status of the render task. <ul>   <li>`queued` - render is queued waiting to be rendered</li>   <li>`fetching` - assets are being fetched</li>   <li>`rendering` - the asset is being rendered</li>   <li>`saving` - the final asset is being saved to storage</li>   <li>`done` - the asset is ready to be downloaded</li>   <li>`failed` - there was an error rendering the asset</li> </ul>
	Status string `json:"status"`

	// An error message, only displayed if an error occurred.
	Error string `json:"error,omitempty"`

	// The output video or audio length in seconds.
	Duration float32 `json:"duration,omitempty"`

	// The time taken to render the asset in milliseconds.
	RenderTime float32 `json:"renderTime,omitempty"`

	// The URL of the final asset. This will only be available if status is done. This is a temporary URL and will be deleted after 24 hours. By default all assets are copied to the Shotstack hosting and CDN destination.
	URL string `json:"url,omitempty"`

	// The URL of the poster image if requested. This will only be available if status is done.
	Poster string `json:"poster,omitempty"`

	// The URL of the thumbnail image if requested. This will only be available if status is done.
	Thumbnail string `json:"thumbnail,omitempty"`

	Data Edit `json:"data"`

	// The time the render task was initially queued.
	Created string `json:"created"`

	// The time the render status was last updated.
	Updated string `json:"updated"`
}

// AssertRenderResponseDataRequired checks if the required fields are not zero-ed
func AssertRenderResponseDataRequired(obj RenderResponseData) error {
	elements := map[string]interface{}{
		"id":      obj.ID,
		"owner":   obj.Owner,
		"status":  obj.Status,
		"data":    obj.Data,
		"created": obj.Created,
		"updated": obj.Updated,
	}
	for name, el := range elements {
		if isZero := IsZeroValue(el); isZero {
			return &RequiredError{Schema: "Render Response Data", Field: name}
		}
	}

	if err := AssertEditRequired(&obj.Data); err != nil {
		return err
	}
	return nil
}

// AssertRecurseRenderResponseDataRequired recursively checks if required fields are not zero-ed in a nested slice.
// Accepts only nested slice of RenderResponseData (e.g. [][]RenderResponseData), otherwise ErrTypeAssertionError is thrown.
func AssertRecurseRenderResponseDataRequired(objSlice interface{}) error {
	return AssertRecurseInterfaceRequired(objSlice, func(obj interface{}) error {
		aRenderResponseData, ok := obj.(RenderResponseData)
		if !ok {
			return ErrTypeAssertionError
		}
		return AssertRenderResponseDataRequired(aRenderResponseData)
	})
}
