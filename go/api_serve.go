/*
shottower
Copyright (C) 2022 RÃ©my Boulanouar

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
/*
 * Shottower
 *
 * Shottower is the open source version of Shotstack which is a video, image and audio editing service that allows for the automated generation of videos, images and audio using JSON and a RESTful API.  You arrange and configure an edit and POST it to the API which will render your media and provide a file  location when complete.  For more details visit [shottower](https://github.com/DblK/shottower) or checkout our [getting started](https://shotstack.io/docs/guide/) documentation.  There are two main API's, one for editing and generating assets (Edit API) and one for managing hosted assets (Serve API).  The Edit API base URL is: <b>http://0.0.0.0:4000/{version}</b>  The Serve API base URL is: <b>http://0.0.0.0:4000/serve/{version}</b>
 *
 * API version: stage
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	// "encoding/json"
	"net/http"
	"strings"

	"github.com/gorilla/mux"
)

// ServeAPIController binds http requests to an api service and writes the service results to the http response
type ServeAPIController struct {
	service      ServeAPIServicer
	errorHandler ErrorHandler
}

// ServeAPIOption for how the controller is set up.
type ServeAPIOption func(*ServeAPIController)

// WithServeAPIErrorHandler inject ErrorHandler into controller
func WithServeAPIErrorHandler(h ErrorHandler) ServeAPIOption {
	return func(c *ServeAPIController) {
		c.errorHandler = h
	}
}

// NewServeAPIController creates a default api controller
func NewServeAPIController(s ServeAPIServicer, opts ...ServeAPIOption) Router {
	controller := &ServeAPIController{
		service:      s,
		errorHandler: DefaultErrorHandler,
	}

	for _, opt := range opts {
		opt(controller)
	}

	return controller
}

// Routes returns all the api routes for the ServeAPIController
func (c *ServeAPIController) Routes() Routes {
	return Routes{
		{
			"DeleteAsset",
			strings.ToUpper("Delete"),
			"/serve/stage/assets/{id}",
			c.DeleteAsset,
		},
		{
			"GetAsset",
			strings.ToUpper("Get"),
			"/serve/stage/assets/{id}",
			c.GetAsset,
		},
		{
			"GetAssetByRenderID",
			strings.ToUpper("Get"),
			"/serve/stage/assets/render/{id}",
			c.GetAssetByRenderID,
		},
	}
}

// DeleteAsset - Delete Asset
func (c *ServeAPIController) DeleteAsset(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	idParam := params["id"]

	result, err := c.service.DeleteAsset(r.Context(), idParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetAsset - Get Asset
func (c *ServeAPIController) GetAsset(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	idParam := params["id"]

	result, err := c.service.GetAsset(r.Context(), idParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetAssetByRenderID - Get Asset by Render ID
func (c *ServeAPIController) GetAssetByRenderID(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	idParam := params["id"]

	result, err := c.service.GetAssetByRenderID(r.Context(), idParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}
