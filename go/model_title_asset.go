/*
shottower
Copyright (C) 2022-2023 RÃ©my Boulanouar

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
/*
 * Shottower
 *
 * Shottower is the open source version of Shotstack which is a video, image and audio editing service that allows for the automated generation of videos, images and audio using JSON and a RESTful API.  You arrange and configure an edit and POST it to the API which will render your media and provide a file  location when complete.  For more details visit [shottower](https://github.com/DblK/shottower) or checkout our [getting started](https://shotstack.io/docs/guide/) documentation.  There are two main API's, one for editing and generating assets (Edit API) and one for managing hosted assets (Serve API).  The Edit API base URL is: <b>http://0.0.0.0:4000/{version}</b>  The Serve API base URL is: <b>http://0.0.0.0:4000/serve/{version}</b>
 *
 * API version: stage
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

// TitleAsset - The TitleAsset clip type lets you create video titles from a text string and apply styling and positioning.
type TitleAsset struct {

	// The type of asset - set to `title` for titles.
	Type string `json:"type"`

	// The title text string - i.e. \"My Title\".
	Text string `json:"text"`

	// Uses a preset to apply font properties and styling to the title. <ul>   <li>`minimal`</li>   <li>`blockbuster`</li>   <li>`vogue`</li>   <li>`sketchy`</li>   <li>`skinny`</li>   <li>`chunk`</li>   <li>`chunkLight`</li>   <li>`marker`</li>   <li>`future`</li>   <li>`subtitle`</li> </ul>
	Style string `json:"style,omitempty"`

	// Set the text color using hexadecimal color notation. Transparency is supported by setting the first two characters of the hex string (opposite to HTML),  i.e. #80ffffff will be white with  50% transparency.
	Color string `json:"color,omitempty"`

	// Set the relative size of the text using predefined sizes from xx-small to xx-large. <ul>   <li>`xx-small`</li>   <li>`x-small`</li>   <li>`small`</li>   <li>`medium`</li>   <li>`large`</li>   <li>`x-large`</li>   <li>`xx-large`</li> </ul>
	Size string `json:"size,omitempty"`

	// Apply a background color behind the text. Set the text color using hexadecimal color notation. Transparency is supported by setting the first two characters of the hex string (opposite to HTML),  i.e. #80ffffff will be white with 50% transparency. Omit to use transparent background.
	Background string `json:"background,omitempty"`

	// Place the title in one of nine predefined positions of the viewport. <ul>   <li>`top` - top (center)</li>   <li>`topRight` - top right</li>   <li>`right` - right (center)</li>   <li>`bottomRight` - bottom right</li>   <li>`bottom` - bottom (center)</li>   <li>`bottomLeft` - bottom left</li>   <li>`left` - left (center)</li>   <li>`topLeft` - top left</li>   <li>`center` - center</li> </ul>
	Position string `json:"position,omitempty"`

	Offset *Offset `json:"offset,omitempty"`
}

func NewTitleAsset(m map[string]interface{}) *TitleAsset {
	titleAsset := &TitleAsset{
		Type: m["type"].(string),
	}

	if m["text"] != nil {
		titleAsset.Text = m["text"].(string)
	}
	if m["style"] != nil {
		titleAsset.Style = m["style"].(string)
	}
	if m["color"] != nil {
		titleAsset.Color = m["color"].(string)
	}
	if m["size"] != nil {
		titleAsset.Size = m["size"].(string)
	}
	if m["background"] != nil {
		titleAsset.Background = m["background"].(string)
	}
	if m["position"] != nil {
		titleAsset.Position = m["position"].(string)
	}
	if m["offset"] != nil {
		titleAsset.Offset = NewOffset(m["offset"].(map[string]interface{}))
	}
	return titleAsset
}

// AssertTitleAssetRequired checks if the required fields are not zero-ed
func AssertTitleAssetRequired(obj TitleAsset) error {
	elements := map[string]interface{}{
		"type": obj.Type,
		"text": obj.Text,
	}
	for name, el := range elements {
		if isZero := IsZeroValue(el); isZero {
			return &RequiredError{Schema: "Title Asset", Field: name}
		}
	}

	if err := AssertOffsetRequired(obj.Offset); err != nil {
		return err
	}
	return nil
}

// AssertRecurseTitleAssetRequired recursively checks if required fields are not zero-ed in a nested slice.
// Accepts only nested slice of TitleAsset (e.g. [][]TitleAsset), otherwise ErrTypeAssertionError is thrown.
func AssertRecurseTitleAssetRequired(objSlice interface{}) error {
	return AssertRecurseInterfaceRequired(objSlice, func(obj interface{}) error {
		aTitleAsset, ok := obj.(TitleAsset)
		if !ok {
			return ErrTypeAssertionError
		}
		return AssertTitleAssetRequired(aTitleAsset)
	})
}
