/*
shottower
Copyright (C) 2022 RÃ©my Boulanouar

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
/*
 * Shottower
 *
 * Shottower is the open source version of Shotstack which is a video, image and audio editing service that allows for the automated generation of videos, images and audio using JSON and a RESTful API.  You arrange and configure an edit and POST it to the API which will render your media and provide a file  location when complete.  For more details visit [shottower](https://github.com/DblK/shottower) or checkout our [getting started](https://shotstack.io/docs/guide/) documentation.  There are two main API's, one for editing and generating assets (Edit API) and one for managing hosted assets (Serve API).  The Edit API base URL is: <b>http://0.0.0.0:4000/{version}</b>  The Serve API base URL is: <b>http://0.0.0.0:4000/serve/{version}</b>
 *
 * API version: stage
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"golang.org/x/exp/slices"
)

// Soundtrack - A music or audio file in mp3 format that plays for the duration of the rendered video or the length of the audio file, which ever is shortest.
type Soundtrack struct {

	// The URL of the mp3 audio file. The URL must be publicly accessible or include credentials.
	Src string `json:"src"`

	// The effect to apply to the audio file <ul>   <li>`fadeIn` - fade volume in only</li>   <li>`fadeOut` - fade volume out only</li>   <li>`fadeInFadeOut` - fade volume in and out</li> </ul>
	Effect string `json:"effect,omitempty"`

	// Set the volume for the soundtrack between 0 and 1 where 0 is muted and 1 is full volume (defaults to 1).
	Volume float32 `json:"volume,omitempty" default:"1"`
}

func (s *Soundtrack) checkEnumValues() error {
	effectValues := []string{"fadeIn", "fadeOut", "fadeInFadeOut"}
	if s.Effect != "" {
		if !slices.Contains(effectValues, s.Effect) {
			return &EnumError{Schema: "Soundtrack", Field: "Effect", Value: s.Effect}
		}
	}
	if s.Volume < 0 || s.Volume > 1 {
		return &EnumError{Schema: "Soundtrack", Field: "Volume", Value: s.Volume}
	}

	return nil
}

// AssertSoundtrackRequired checks if the required fields are not zero-ed
func AssertSoundtrackRequired(obj *Soundtrack) error {
	if obj == nil {
		return nil
	}
	elements := map[string]interface{}{
		"src": obj.Src,
	}

	if err := obj.checkEnumValues(); err != nil {
		return err
	}

	for name, el := range elements {
		if isZero := IsZeroValue(el); isZero {
			return &RequiredError{Schema: "Soundtrack", Field: name}
		}
	}

	return nil
}

// AssertRecurseSoundtrackRequired recursively checks if required fields are not zero-ed in a nested slice.
// Accepts only nested slice of Soundtrack (e.g. [][]Soundtrack), otherwise ErrTypeAssertionError is thrown.
func AssertRecurseSoundtrackRequired(objSlice interface{}) error {
	return AssertRecurseInterfaceRequired(objSlice, func(obj interface{}) error {
		aSoundtrack, ok := obj.(Soundtrack)
		if !ok {
			return ErrTypeAssertionError
		}
		return AssertSoundtrackRequired(&aSoundtrack)
	})
}
