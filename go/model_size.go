/*
shottower
Copyright (C) 2022-2023 RÃ©my Boulanouar

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
/*
 * Shottower
 *
 * Shottower is the open source version of Shotstack which is a video, image and audio editing service that allows for the automated generation of videos, images and audio using JSON and a RESTful API.  You arrange and configure an edit and POST it to the API which will render your media and provide a file  location when complete.  For more details visit [shottower](https://github.com/DblK/shottower) or checkout our [getting started](https://shotstack.io/docs/guide/) documentation.  There are two main API's, one for editing and generating assets (Edit API) and one for managing hosted assets (Serve API).  The Edit API base URL is: <b>http://0.0.0.0:4000/{version}</b>  The Serve API base URL is: <b>http://0.0.0.0:4000/serve/{version}</b>
 *
 * API version: stage
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"math"

	"github.com/spf13/cast"
)

// Size - Set a custom size for a video or image. When using a custom size omit the `resolution` and `aspectRatio`. Custom sizes must be divisible by 2 based on the encoder specifications.
type Size struct {

	// Set a custom width for the video or image file. Value must be divisible by 2. Maximum video width is 1920px, maximum image width is 4096px.
	Width *int32 `json:"width,omitempty"`

	// Set a custom height for the video or image file. Value must be divisible by 2. Maximum video height is 1920px, maximum image height is 4096px.
	Height *int32 `json:"height,omitempty"`
}

func NewSize(m map[string]interface{}) *Size {
	size := &Size{}

	if m["width"] != nil {
		width := cast.ToInt32(m["width"].(float64))
		size.Width = &width
	}
	if m["height"] != nil {
		height := cast.ToInt32(m["height"].(float64))
		size.Height = &height
	}
	return size
}

func (s *Size) checkEnumValues() error {
	if s.Width != nil {
		if *s.Width < 2 || *s.Width > 4096 || math.Mod(float64(*s.Width), 2) != 0 {
			return &EnumError{Schema: "Size", Field: "Width", Value: *s.Width}
		}
	}

	if s.Height != nil {
		if *s.Height < 2 || *s.Height > 4096 || math.Mod(float64(*s.Height), 2) != 0 {
			return &EnumError{Schema: "Size", Field: "Height", Value: *s.Height}
		}
	}

	return nil
}

// AssertSizeRequired checks if the required fields are not zero-ed
func AssertSizeRequired(obj *Size) error {
	if obj == nil {
		return nil
	}

	if err := obj.checkEnumValues(); err != nil {
		return err
	}

	return nil
}

// AssertRecurseSizeRequired recursively checks if required fields are not zero-ed in a nested slice.
// Accepts only nested slice of Size (e.g. [][]Size), otherwise ErrTypeAssertionError is thrown.
func AssertRecurseSizeRequired(objSlice interface{}) error {
	return AssertRecurseInterfaceRequired(objSlice, func(obj interface{}) error {
		aSize, ok := obj.(Size)
		if !ok {
			return ErrTypeAssertionError
		}
		return AssertSizeRequired(&aSize)
	})
}
