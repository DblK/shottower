/*
shottower
Copyright (C) 2022-2023 RÃ©my Boulanouar

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
/*
 * Shottower
 *
 * Shottower is the open source version of Shotstack which is a video, image and audio editing service that allows for the automated generation of videos, images and audio using JSON and a RESTful API.  You arrange and configure an edit and POST it to the API which will render your media and provide a file  location when complete.  For more details visit [shottower](https://github.com/DblK/shottower) or checkout our [getting started](https://shotstack.io/docs/guide/) documentation.  There are two main API's, one for editing and generating assets (Edit API) and one for managing hosted assets (Serve API).  The Edit API base URL is: <b>http://0.0.0.0:4000/{version}</b>  The Serve API base URL is: <b>http://0.0.0.0:4000/serve/{version}</b>
 *
 * API version: stage
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"strings"

	"golang.org/x/exp/slices"
)

// Transition - In and out transitions for a clip - i.e. fade in and fade out
type Transition struct {

	// The transition in. Available transitions are:   <ul>     <li>`fade` - fade in</li>     <li>`reveal` - reveal from left to right</li>     <li>`wipeLeft` - fade across screen to the left</li>     <li>`wipeRight` - fade across screen to the right</li>     <li>`slideLeft` - move slightly left and fade in</li>     <li>`slideRight` - move slightly right and fade in</li>     <li>`slideUp` - move slightly up and fade in</li>     <li>`slideDown` - move slightly down and fade in</li>     <li>`carouselLeft` - slide in from right to left</li>     <li>`carouselRight` - slide in from left to right</li>     <li>`carouselUp` - slide in from bottom to top</li>     <li>`carouselDown` - slide in from top to bottom</li>     <li>`shuffleTopRight` - rotate in from top right</li>     <li>`shuffleRightTop` - rotate in from right top</li>     <li>`shuffleRightBottom` - rotate in from right bottom</li>     <li>`shuffleBottomRight` - rotate in from bottom right</li>     <li>`shuffleBottomLeft` - rotate in from bottom left</li>     <li>`shuffleLeftBottom` - rotate in from left bottom</li>     <li>`shuffleLeftTop` - rotate in from left top</li>     <li>`shuffleTopLeft` - rotate in from top left</li>     <li>`zoom` - fast zoom in</li>   </ul> The transition speed can also be controlled by appending `Fast` or `Slow` to the transition, e.g. `fadeFast` or `CarouselLeftSlow`.
	In string `json:"in,omitempty"`

	// The transition out. Available transitions are:   <ul>     <li>`fade` - fade out</li>     <li>`reveal` - reveal from right to left</li>     <li>`wipeLeft` - fade across screen to the left</li>     <li>`wipeRight` - fade across screen to the right</li>     <li>`slideLeft` - move slightly left and fade out</li>     <li>`slideRight` - move slightly right and fade out</li>     <li>`slideUp` - move slightly up and fade out</li>     <li>`slideDown` - move slightly down and fade out</li>     <li>`carouselLeft` - slide out from right to left</li>     <li>`carouselRight` - slide out from left to right</li>     <li>`carouselUp` - slide out from bottom to top</li>     <li>`carouselDown` - slide out from top  to bottom</li>     <li>`shuffleTopRight` - rotate out from top right</li>     <li>`shuffleRightTop` - rotate out from right top</li>     <li>`shuffleRightBottom` - rotate out from right bottom</li>     <li>`shuffleBottomRight` - rotate out from bottom right</li>     <li>`shuffleBottomLeft` - rotate out from bottom left</li>     <li>`shuffleLeftBottom` - rotate out from left bottom</li>     <li>`shuffleLeftTop` - rotate out from left top</li>     <li>`shuffleTopLeft` - rotate out from top left</li>     <li>`zoom` - fast zoom out</li>   </ul> The transition speed can also be controlled by appending `Fast` or `Slow` to the transition, e.g. `fadeFast` or `CarouselLeftSlow`.
	Out string `json:"out,omitempty"`
}

func NewTransition(m map[string]interface{}) *Transition {
	transition := &Transition{}

	if m["in"] != nil {
		transition.In = m["in"].(string)
	}
	if m["out"] != nil {
		transition.Out = m["out"].(string)
	}
	return transition
}

func (s *Transition) ConvertTransitionName(t string) string {
	newTransition := t

	// shotstack renamed transitions
	if newTransition[0:7] == "carousel" {
		newTransition = strings.Replace(newTransition, "carousel", "slide", 1)
	}
	switch newTransition {
	case "reveal":
		newTransition = "wipeLeft"
	case "zoom":
		newTransition = "zoomIn"
	// missing ffmpeg transitions
	case "diagBottomLeft":
		newTransition = "diagBl"
	case "diagBottomRight":
		newTransition = "diagBr"
	case "diagTopLeft":
		newTransition = "diagTl"
	case "diagTopRight":
		newTransition = "diagTr"
	case "horizontalLeftSlice":
		newTransition = "hlSlice"
	case "horizontalRightSlice":
		newTransition = "hrSlice"
	case "verticalUpSlice":
		newTransition = "vuSlice"
	case "verticalDownSlice":
		newTransition = "vdSlice"
	case "horizontalBlur":
		newTransition = "hBlur"
	case "wipeTopLeft":
		newTransition = "wipeTl"
	case "wipeTopRight":
		newTransition = "wipeTr"
	case "wipeBottomLeft":
		newTransition = "wipeBl"
	case "wipeBottomRight":
		newTransition = "wipeBr"
	case "squeezeVertical":
		newTransition = "squeezeV"
	case "squeezeHorizontal":
		newTransition = "squeezeH"
	}

	return strings.ToLower(newTransition)
}

func (s *Transition) checkEnumValues() error {
	// TODO: Add unsupported "shuffleTopRight", "shuffleRightTop", "shuffleRightBottom", "shuffleBottomRight", "shuffleBottomLeft", "shuffleLeftBottom", "shuffleLeftTop"
	values := []string{"fade", "reveal", "wipeLeft", "wipeRight", "slideLeft", "slideRight", "slideUp", "slideDown", "carouselLeft", "carouselRight", "carouselUp", "carouselDown", "zoom", "fadeBlack", "fadeWhite", "distance", "wipeUp", "wipeDown", "smoothLeft", "smoothRight", "smoothUp", "smoothDown", "circleCrop", "rectCrop", "circleClose", "circleOpen", "horzClose", "horzOpen", "vertClose", "vertOpen", "diagBottomLeft", "diagBottomRight", "diagTopLeft", "diagTopRight", "horizontalLeftSlice", "horizontalRightSlice", "verticalUpSlice", "verticalDownSlice", "dissolve", "pixelize", "radial", "horizontalBlur", "wipeTopLeft", "wipeTopRight", "wipeBottomLeft", "wipeBottomRight", "fadeGrays", "squeezeVertical", "squeezeHorizontal"}
	valuesFast := []string{}
	valuesSlow := []string{}
	for _, value := range values {
		if value != "zoom" {
			valuesFast = append(valuesFast, value+"Fast")
			valuesSlow = append(valuesSlow, value+"Slow")
		}
	}

	if s.In != "" && !slices.Contains(values, s.In) && !slices.Contains(valuesFast, s.In) && !slices.Contains(valuesSlow, s.In) {
		return &EnumError{Schema: "Transition", Field: "In", Value: s.In}
	}

	if s.Out != "" && !slices.Contains(values, s.Out) && !slices.Contains(valuesFast, s.Out) && !slices.Contains(valuesSlow, s.Out) {
		return &EnumError{Schema: "Transition", Field: "Out", Value: s.Out}
	}

	return nil
}

// AssertTransitionRequired checks if the required fields are not zero-ed
func AssertTransitionRequired(obj *Transition) error {
	if obj == nil {
		return nil
	}

	if err := obj.checkEnumValues(); err != nil {
		return err
	}

	return nil
}

// AssertRecurseTransitionRequired recursively checks if required fields are not zero-ed in a nested slice.
// Accepts only nested slice of Transition (e.g. [][]Transition), otherwise ErrTypeAssertionError is thrown.
func AssertRecurseTransitionRequired(objSlice interface{}) error {
	return AssertRecurseInterfaceRequired(objSlice, func(obj interface{}) error {
		aTransition, ok := obj.(Transition)
		if !ok {
			return ErrTypeAssertionError
		}
		return AssertTransitionRequired(&aTransition)
	})
}
